<?xml version="1.0" encoding="UTF-8"?><html xmlns:concordion="http://www.concordion.org/2007/concordion"><head><style>* {
  font-family: Arial;
}
body {
  padding: 32px;  
}
pre {
  padding: 6px 28px 6px 28px;
  background-color: #E8EEF7;
}
pre, pre *, code, code *, kbd {
  font-family: Courier New, Courier;
  font-size: 10pt;
}
h1, h1 * {
  font-size: 24pt;	
}
p, td, th, li, .breadcrumbs {
  font-size: 10pt;
}
p, li {
  line-height: 140%;
  max-width: 720px;
}
table {
  border-collapse: collapse;
  empty-cells: show;
  margin: 8px 0px 8px 0px;
}
th, td {
  border: 1px solid black;
  padding: 3px;
}
td {
  background-color: white;
  vertical-align: top;
}
th {
  background-color: #C3D9FF;
}
li {
  margin-top: 6px;
  margin-bottom: 6px; 
}

.example {
  padding: 6px 16px 6px 16px;
  border: 1px solid #C3D9FF;
  margin: 6px 0px 28px 0px;
  background-color: #F5F9FD;
}
.example h3 {
  margin-top: 8px;
  margin-bottom: 8px;
  font-size: 12pt;
}

p.success {
  padding: 2px;
}
.success, .success * {
  background-color: #afa !important;
}
.success pre {
  background-color: #bbffbb;
}
.failure, .failure * {
  background-color: #ffb0b0;
  padding: 1px;
}
.failure .expected {
  text-decoration: line-through;
  color: #bb5050;
}
.ignored, .ignored * {
  background-color: #f0f0f0 !important;	
}

ins {
  text-decoration: none;	
}

.exceptionMessage {
  background-color: #fdd;
  font-family: Courier New, Courier, Monospace;
  font-size: 10pt;
  display: block;
  font-weight: normal;
  padding: 4px;
  text-decoration: none !important;
}
.stackTrace, .stackTrace * {
  font-weight: normal;
}
.stackTrace {
  display: none;
  padding: 1px 4px 4px 4px;
  background-color: #fdd;
  border-top: 1px dotted black;
}
.stackTraceExceptionMessage {
  display: block;
  font-family: Courier New, Courier, Monospace;
  font-size: 8pt;
  white-space: wrap;
  padding: 1px 0px 1px 0px;
}
.stackTraceEntry {
  white-space: nowrap;
  font-family: Courier New, Courier, Monospace;
  display: block;
  font-size: 8pt;
  padding: 1px 0px 1px 32px;
}
.stackTraceButton {
  font-size: 8pt;
  margin: 2px 8px 2px 0px;
  font-weight: normal;
  font-family: Arial;
}

.special {
  font-style: italic;
}
.missing, .missing * {
  background-color: #ff9999;
  color:#bb5050;
  text-decoration: line-through;
}
.surplus, .surplus * {
  background-color: #ff9999;
}
.footer {
  text-align: right;
  margin-top: 40px;
  font-size: 8pt;
  width: 100%;
  color: #999;
}
.footer .testTime {
  padding: 2px 10px 0px 0px;
}

.idea {
  font-size: 9pt;
  color: #888;
  font-style: italic;	
}
.tight li {
  margin-top: 1px;
  margin-bottom: 1px; 
}
.commentary {
  float: right;
  width: 200px;
  background-color: #ffffd0;
  padding:8px;
  border: 3px solid #eeeeb0;	 
  margin: 10px 0px 10px 10px;	 
}
.commentary, .commentary * {
  font-size: 8pt;
}
</style><meta http-equiv="content-type" content="text/html; charset=UTF-8" />
</head><body>
<h1>Collect all text contained in a parsed tree</h1>
<p>One common task is to collect all text content for a tree or subtree:  that is, all text contained in a node and any of the nodes recursively contained by it. This requires collecting the String value of all contained text nodes in document order, while taking account of XML's treatment of white space outside of text nodes as not significant. The convention of the <code>XmlNode</code> class is to reduce spaces between elements to a single space character.</p>
<p><div class='example'></p>
<h3>Example: recursive extraction</h3>
<p>The first part of the text content of this well-formed XML fragment is found in direct children of the root element, but the document's text continues in hierarchically separated subelements.</p>
<p><code concordion:set="#il1">&lt;l n="1"&gt;Sing, goddess, the rage of &lt;persName n="urn:cite:hmt:pers.pers1"&gt;Achilles&lt;/persName&gt;&lt;/l&gt;</code></p>
<p>When we extract the text from this node, we correctly get the single continuous string <strong concordion:assertEquals="collectText(#il1)" class="success">Sing, goddess, the rage of Achilles</strong></p>
<p></div></p>
<p><div class='example'></p>
<h3>Example: reduction of white space</h3>
<p>Extra spaces in the XML document are regularized to a single white space character. In the following well-formed XML fragment, the text contents are identical to the preceding example, but white space is used differently in the markup:</p>
<p><code concordion:set="#extrawhite">&lt;l n="1"&gt;Sing, goddess, the rage of  &lt;persName     n="urn:cite:hmt:pers.pers1"       &gt;Achilles&lt;/persName&gt;     &lt;/l&gt;
</code></p>
<p>When we extract the text contents from this node, we correctly get an identical string <strong concordion:assertEquals="collectText(#extrawhite)" class="success">Sing, goddess, the rage of Achilles</strong>
</div></p>
<p><div class='example'></p>
<h3>Example: adjacent elements</h3>
<p>This example illustrates how the <code>collectText()</code> method separates strings extracted from distinct elements with a white space.  This markup markup is a possible encoding of (the beginning of) Shelley's <em>Ozymandias</em>. There is no white space at the end of the first poetic line and none at the beginning of the second line.</p>
<p><code concordion:set="#twolines">&lt;div&gt;&lt;l n="1"&gt;I met a traveller from an antique land&lt;/l&gt;&lt;l n="2"&gt;Who said &lt;/l&gt;&lt;/div&gt;</code></p>
<p><code>collectText()</code> correctly separates the last word of line 1 from the first word of line 2:</p>
<p><strong concordion:assertEquals="collectText(#twolines)" class="success">I met a traveller from an antique land Who said</strong></p>
<p></div></p>
<h3>Markup for explicit tokenization</h3>
<p>Sometimes we want to override the default behavior of separating text content of adjacent elements.  The <code>XmlNode</code> class supports optionally defining markup conventions that cluster contained content into a single token.  Any of the following conventions may be used to define tokenizing markup:</p>
<ol>
<li>A specified element, either namespace-qualified or not.</li>
<li>A specified attribute.</li>
<li>A specified value on a specified attribute.</li>
<li>A specified attribute on a specified element, either namespace-qualified or not.</li>
<li>A specified value on a specified attribute on a specified element, either namespace-qualified or not.</li>
</ol>
<p><div class='example'></p>
<h3>Example: tokenize contents of a specified element</h3>
<p>Editors of historical documents might need to identify unclear sections, as illustrated in this example:</p>
<p><code concordion:set="#unclear">&lt;l&gt;Sing, &lt;w&gt;god&lt;unclear&gt;dess&lt;/unclear&gt;&lt;/w&gt;&lt;/l&gt;</code></p>
<p>Extracting text context with default settings will yield the string
<strong concordion:assertEquals="collectText(#unclear)" class="success">Sing, god dess</strong></p>
<p>If we define the <strong concordion:set="#magicelem">w</strong> element as containing a single token, we instead get the string <strong concordion:assertEquals="collectTextByElem(#magicelem,#unclear)" class="success">Sing, goddess</strong></p>
<p></div></p>
<p><div class='example'></p>
<h3>Example: tokenize contents identified by attribute  name</h3>
<p>We can configure <code>XmlNode</code> to recognize tokenizing markup by attribute name. In the following example, the <code>w</code> element has an <code>ana</code> attribute.</p>
<p><code concordion:set="#ana">&lt;l&gt;Sing, &lt;w ana="token"&gt;god&lt;unclear&gt;dess&lt;/unclear&gt;&lt;/w&gt;&lt;/l&gt;</code></p>
<p>If we extract the text with default settings, we again get the string <strong concordion:assertEquals="collectText(#ana)" class="success">Sing, god dess</strong></p>
<p>If we define the <strong concordion:set="#magicattr">ana</strong> attribute as identifyiing a tokenizing element, we instead get the string <strong concordion:assertEquals="collectTextByAttrName(#magicattr,#ana)" class="success">Sing, goddess</strong></p>
<p></div></p>
<p><div class='example'></p>
<h3>Example: tokenize contents identified by attribute name + value</h3>
<p>The following snippet has markup identifying a punctuation character, and uses the <code>ana</code> attributes with two different values.</p>
<p><code concordion:set="#anaval">&lt;l&gt;&lt;w ana="multitoken"&gt;Sing&lt;punct&gt;,&lt;/punct&gt;&lt;/w&gt; &lt;w ana="token"&gt;god&lt;unclear&gt;dess&lt;/unclear&gt;&lt;/w&gt;&lt;/l&gt;</code></p>
<p>If we extract the text with default settings, we again get the string <strong concordion:assertEquals="collectText(#anaval)" class="success">Sing , god dess</strong></p>
<p>We can configure <code>XmlNode</code> to recognize tokenizing markup by a combination of attribute name and value. Using the markup from the preceding example, we could set the <code concordion:set="#magicattname">ana</code> attribute to mark tokenizing elements <em>only</em> when it has the value <strong concordion:set="#magicval">token</strong>. When we collect the text from this sample, the contents of the element with <code>ana</code> attribute = <code>multitoken</code> will follow the default behavior of separating subelements, while the contents of the element with <code>ana</code> attribute = <code>token</code> will group that text in a single string with no whitespace, producing the string <strong concordion:assertEquals="collectTextByAttrValue(#magicattname,#magicval, #anaval)" class="success">Sing , goddess</strong></p>
<p></div></p>
<p><div class='example'></p>
<h3>Examples: limiting defining attributes to a specific element</h3>
<p>In this example, we have an <code>ana</code> attribute with value <code>token</code> on two different elements.</p>
<p><code concordion:set="#anavalelem">&lt;l&gt;&lt;seg ana="token"&gt;Sing&lt;punct&gt;,&lt;/punct&gt;&lt;/seg&gt; &lt;w ana="token"&gt;god&lt;unclear&gt;dess&lt;/unclear&gt;&lt;/w&gt;&lt;/l&gt;</code></p>
<p>Extracting the text with default settings, again yields the string <strong concordion:assertEquals="collectText(#anavalelem)" class="success">Sing , god dess</strong></p>
<p>Now we add the restriction that the <code>token</code> value on <code>ana</code> only identifies tokenizing markup when on the element <code>w</code>.  The contents of the <code>seg</code> element will be broken up using the default rules, while the contents of the <code>w</code> element will be <strong concordion:assertEquals="collectTextByAttrValueOnElem(#magicelem,#magicattname,#magicval, #anaval)" class="success">Sing , goddess</strong></p>
<p></div></p>
<h2>Planned for next release: serialize a node</h2>
<p>The task of re-serializing a node and its contents to XML is tedious.  One compilication is that in some contexts, it may be desirable to include explicit XML namespace definitions if serializing a subtree when the XML namespace is defined in a containing element.</p>
<div class="footer">Results generated by <a href="http://www.concordion.org" style="font-weight: bold; text-decoration: none; color: #89C;">Concordion</a><div class="testTime">in 578 ms on 14-Nov-2015 at 04:36:26 EST</div></div></body>
</html>